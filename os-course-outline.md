# 教学日历（教学大纲）（48学时）

大纲修定历史：

* [v1](https://github.com/LearningOS/os-lectures/blob/c3933c913abdedbda15a25ad85e33f166fae38fc/os-course-outline.md)
* [v2](https://github.com/LearningOS/os-lectures/blob/9ffa747971086b88f8045b04ae012c82ad837414/os-course-outline.md)：2020年10月21日提交给系里的版本；
* [v3](https://github.com/LearningOS/os-lectures/blob/e00265613daeafffa9fa4d1a53def7b5ed92016a/os-course-outline.md): 21 Oct 2020
* [v4](https://github.com/LearningOS/os-lectures/blob/1d07e4bfc55af586079499db65f926b52c0afeb1/os-course-outline.md): cooperate with 2021-spring labs
* [v5](https://github.com/LearningOS/os-lectures/blob/f001a6c5bacc7be80e27a168959c288c91ec1639/os-course-outline.md): 2021年秋季学期结束时更新教学内容部分

## 课程组织与基本目的

操作系统是计算机系统中负责管理各种软硬件资源的核心系统软件，掌握操作系统的基本原理及其设计实现技术是研究型大学计算机专业本科毕业生的基本要求。

本课程是计算机专业核心课，从计算机系统的视角进行内容组织与调整，以教学操作系统uCore/rCore和risc-v CPU为实验环境，讲授操作系统的概念、基本原理和实现技术，并介绍部分当前操作系统研究热点和论文，帮助学生了解和掌握大型复杂系统软件的分析方法和核心设计思路，并为学生充分利用操作系统功能进行应用软件研究和开发打下扎实的基础。

下面的每一讲是两个课时

## 教学内容

## 第一部分 操作系统基础

### 

### 第一讲 操作系统概述

#### 1.1 课程概述&教学安排

#### 1.2 OS实验概述

#### 1.3 什么是操作系统

#### 1.4 操作系统历史演变

#### 1.5 操作系统抽象

#### 1.6 操作系统特征

#### 1.7 操作系统结构

#### 1.8 实验：应用程序与基本执行环境



### 第二讲 特权级与系统调用

#### 2.1 从OS角度看看应用程序

#### 2.2 从OS角度看计算机系统

#### 2.3 从OS角度再理解RISC-V

#### 2.4 kernel mode操作系统

#### 2.5 实验：批处理操作系统

##### 2.5.1 应用程序设计

##### 2.5.2 加载应用程序

##### 2.5.3 特权级切换



### 第三讲 多道程序与分时多任务

#### 3.1 多道程序概念

#### 3.2 分时多任务概念

#### 3.3 协作式调度

#### 3.4 抢占式调度

#### 3.5 中断处理

#### 3.6 实验：多道程序与分时多任务

##### 3.6.1 上下文切换

##### 3.6.2 协作式调度

##### 3.6.3 中断机制

##### 3.6.4 抢占式调度



### 第四讲：地址空间

#### 4.1 计算机体系结构和内存层次

#### 4.2 静态内存分配

#### 4.3 动态内存分配（连续内存分配算法）

#### 4.4 地址空间

#### 4.5  页式存储管理

#### 4.6 实验：地址空间

##### 4.6.1 管理sv39多级页表

##### 4.6.2 内核与应用的地址空间

##### 4.6.3 基于地址空间的分时多任务

#### 4.7 页表自映射（option）



### 第五讲 进程管理与调度

#### 5.1 进程概念

#### 5.2 进程管理

#### 5.3 系统调用

#### 5.4  实验：进程管理

##### 5.4.1 应用示例

##### 5.4.2 进程的数据结构

##### 5.4.3 进程管理机制的实现

##### 5.5 单处理机调度

#### 5.5.1 处理机调度概念

#### 5.5..2 调度准则

#### 5.5.3 调度算法

#### 5.5.4 实时调度

#### 5.5.5 优先级反置

#### 

### 第六讲 文件系统

#### 6.1 文件系统概述

#### 6.2 文件系统接口

#### 6.3 文件系统实现(涉及 VFS)

#### 6.4 实验：文件系统

##### 6.4.1 easyfs简介

##### 6.4.2 块设备接口

##### 6.4.3 块缓冲层

##### 6.4.4 磁盘布局与管理

##### 6.4.5 索引节点

##### 6.4.6 在内核中接入easy-fs

#### 6.5 实例：进程文件系统 procfs



### 第七讲 进程间通信

#### 7.1  进程通信概念

#### 7.2 信号

#### 7.3 管道

#### 7.4 消息队列

#### 7.5 共享内存

#### 7.6 实验：进程间通信与I/O重定向

##### 7.6.1 标准I/O

##### 7.6.2 管道

##### 7.6.3 命令行参数与I/O重定向

#### 7.7 D-Bus机制（option）

#### 7.8 Binder机制（option）



### 第八讲 线程与同步互斥-1

#### 8.1 线程概念与管理

#### 8.2 现实生活中的同步问题

#### 8.3 临界区

#### 8.4 禁用硬件中断

#### 8.5 基于软件的解决方法

#### 8.6 更高级的抽象方法

#### 8.7 信号量

#### 8.8 管程

#### 

### 第九讲 线程与同步互斥-2

#### 9.1 哲学家就餐问题（信号量/管程）

#### 9.2 读者-写者问题（信号量/管程）

#### 9.3 死锁概念

#### 9.4 死锁处理方法

#### 9.5 银行家算法

#### 9.6 死锁检测

#### 9.7 并发错误检测（option）

#### 9.8 实验：并发

##### 9.8.1 线程实现

##### 9.8.2 锁机制实现

##### 9.8.3 信号量机制

##### 9.8.4 条件变量机制



### 第十讲 虚拟存储-1

#### 10.1 局部性原理

#### 10.2 覆盖和交换

#### 10.3 虚拟页式存储

#### 10.4 RISC-V 缺页异常

#### 10.5 页面置换算法的概念

#### 10.6 最优算法、先进先出算法和最近最久未使用算法

#### 10.7 时钟置换算法和最不常用算法

#### 10.8 Belady现象和局部置换算法比较

#### 10.9 全局页面置换算法

#### 10.11 工作集置换算法

#### 

### 第十一讲 虚拟存储-2

#### 11.1 缺页率置换算法

#### 11.2 抖动和负载控制

#### 11.3 FBR:访问频率置换算法

#### 11.4 面向缓存的页替换算法 – LRU-K & 2Q

#### 11.5 面向缓存的页替换算法 – LIRS

## 

### 第十二讲 I/O设备管理

#### 12.1 设备概述

#### 12.2 设备抽象

#### 12.3 设备执行模型

#### 12.4 实验：I/O设备管理

##### 12.4.1 外设平台

##### 12.4.2 串口驱动

##### 12.4.3 virtio设备驱动



## 第十三讲 多处理器调度与调度实例

#### 13.1 对称多处理与多核架构

#### 13.2 多处理器调度概述

#### 13.3 O(1) 调度

#### 13.4 CFS调度

#### 14.5 BFS调度算法

#### 

### 第十四讲 可靠文件系统与文件系统实例

#### 14.1 系统可靠性概述

#### 14.2 基于日志的文件系统

#### 14.3 FAT文件系统（option）

#### 14.4 EXT4文件系统（option）

#### 14.5 NTFS（option）

#### 14.6 Zettabyte File System (ZFS)（option）

#### 14.7 数据库文件系统（option）



### 第十五讲  同步互斥实例

#### 15.1 读写信号量

#### 15.2 睡眠锁机制

#### 15.3 RCU机制

### 15.4 futex机制



### 第十六讲 系统级虚拟化

#### 16.1 系统虚拟化概述

#### 16.2 处理器虚拟化

#### 16.3 内存虚拟化

#### 16.4 I/O虚拟化

#### 16.5 虚拟化实例：RVM/Rvirt

## 

### 第十七讲 分布式系统

#### 17.1 分布式系统概述

#### 17.2 分布式文件系统

#### 17.3 RDMA: Remote Direct Memory Access

#### 17.4 分布式软总线

### 

### 第十八讲 异步编程 (Asynchronous Programming)

#### 18.1 Background

#### 18.2 Futures in Rust

#### 18.3 Generators and async/await

#### 18.4 Self-Referential Structs & Pin

#### 18.5 Waker and Reactor

### 

### ## 教学实验

### 实验0：操作系统实验环境和工具

- 实验目的：了解和熟悉操作系统实验的编译方法和流程、基于硬件模拟器的操作系统内核调试方法，复习Rust语言和RISC-V汇编语言。
- 实验内容：安装Linux操作系统、Rust编译工具和QEMU硬件模拟器，并熟悉这些系统和工具的使用方法。

### 实验1：hello-world OS

- 实验目的：了解：在裸机上的执行环境，让应用与硬件隔离，简化了应用访问硬件的难度和复杂性。
- 实验内容：直接与硬件交互的系统程序的编译运行、 输出字符的方法、调试系统程序的方法。

### 实验2：kernel-mode OS

- 实验目的：了解：操作系统利用硬件特权级机制，实现对操作系统自身的保护；应用在用户态通过系统调用得到内核态的内核服务；
  操作系统批处理机制支持多个程序的自动加载和运行。
- 实验内容：特权级机制、应用程序实现、批处理机制、特权级切换。

### 实验3：multi-programming OS

- 实验目的：了解：操作系统通过协作机制/抢占机制支持程序主动/被动放弃处理器，提高系统效率。
- 实验内容：多道程序的放置与加载、任务切换、协作式调度、抢占式调度。 

### 实验4：mem-isolation OS

- 实验目的：了解：操作系统通过动态内存分配机制、页表的虚实内存映射机制，加强内存安全，简化应用开发。
- 实验内容：动态内存分配、地址空间(Address Space)抽象、多级页表

### 实验5：multi-process OS

- 实验目的：了解：操作系统建立了进程创建、执行、切换和结束的动态管理过程。
- 实验内容：进程(Process)抽象、进程管理。

### 实验6：File-System OS

- 实验目的：了解：操作系统通过文件系统完成对程序和数据的持久保存与灵活的访问。
- 实验内容：基于inode方式的文件系统的设计与实现。

### 实验7：Inter-Process-Comm OS

- 实验目的：了解：操作系统通过进程间通信(Inter-Process-Comm)机制，让应用之间建立了有效的联系。
- 实验内容：进程间通信机制、管道(PIPE)机制。

 

### 实验8：r/u Core OS-next（device or other features）

- 实验目的：了解：为支持更丰富的应用需求，操作系统需要改进与完善；通过完成一个完整的OS kernel的设计与实现，形成面向操作系统的系统思维。
- 实验内容：操作系统各组成部分关联关系的完善、操作系统各组成部分的改进与优化、对应用的进一步服务与支持。可以是支持设备驱动，形成丰富多彩的应用。
