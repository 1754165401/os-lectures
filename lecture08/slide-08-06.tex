\input{../preamble}
%\def\imagepath{./resources/graphics}
%\usepackage[imagepath=\imagepath]{ditaa}
%\graphicspath{ {\imagepath/} }


%\usepackage{pgfpages}
%\setbeameroption{show notes on second screen}
%%----------------------------------------------------------------------------------------
%	TITLE PAGE
%----------------------------------------------------------------------------------------

\title[第8讲]{第8讲 ：全局页替换算法} % The short title appears at the bottom of every slide, the full title is only on the title page
\subtitle{第四节：面向缓存的页替换算法-part2}
\author{向勇、陈渝} % Your name
\institute[清华大学] % Your institution as it will appear on the bottom of every slide, may be shorthand to save space
{
	清华大学计算机系 \\ % Your institution for the title page
	\medskip
	\textit{xyong,yuchen@tsinghua.edu.cn} % Your email address
}
\date{\today} % Date, can be changed to a custom date


\begin{document}

\begin{frame}
\titlepage % Print the title page as the first slide
\end{frame}

%\begin{frame}
%\frametitle{提纲} % Table of contents slide, comment this block out to remove it
%\tableofcontents % Throughout your presentation, if you choose to use \section{} and \subsection{} commands, these will automatically be printed on this slide as an overview of your presentation
%\end{frame}
%
%%----------------------------------------------------------------------------------------
%%	PRESENTATION SLIDES
%%----------------------------------------------------------------------------------------

%----------------------------------------------
\begin{frame}[plain]
	\frametitle{ }
	\begin{columns}
		\begin{column}{.1\textwidth}
			\centering
%			\includegraphics[width=.6\textwidth]{mem-trash}
			%			\includegraphics[width=1.2\textwidth]{btree}
		\end{column}
		
		\begin{column}{.9\textwidth}
			
			\begin{itemize}
				\item 有更简洁的LRU+LFU的设计思路吗? 能够应对：
				\begin{itemize}
					
					\item 顺序访问：所有的块一个接一个被访问，不存在重访问
					\item 循环访问：所有块都按照一定的间隔重复访问
					\item 时间密集访问：最近被访问的块是将来最有可能被访问的
					\item 概率访问：所有块都有固定的访问概率，所有块都互相独立地根据概率被访问
					
					
				\end{itemize}
			\end{itemize}
		\centering
			最近使用过K次？
			
		\end{column}
		
		
	\end{columns}
\end{frame}



%----------------------------------------------
\begin{frame}[plain]
	\frametitle{ }
	\begin{columns}
		\begin{column}{.4\textwidth}
			\centering
			%			\includegraphics[width=.6\textwidth]{mem-trash}
			\includegraphics[width=1.\textwidth]{lru-k}
		\end{column}
		
		\begin{column}{.6\textwidth}
			
			\begin{itemize}
				\item LRU-K
				\begin{itemize}
					
					\item LRU-K是基于LRU算法的扩展，其中K代表最近访问的次数，从某种意义上，LRU可以看作是LRU-1算法，引入K的意义是为了解决缓存污染问题。
					\item 其核心理念是从“数据最近被访问过1次”蜕变成“数据最近被访问过K次，那么将来被访问的概率会更高”。
					
					
				\end{itemize}
			\end{itemize}
			
			
		\end{column}
		
		
	\end{columns}
\end{frame}


%----------------------------------------------
\begin{frame}[plain]
	\frametitle{ }
	\begin{columns}
		\begin{column}{.4\textwidth}
			\centering
			%			\includegraphics[width=.6\textwidth]{mem-trash}
			\includegraphics[width=1.\textwidth]{lru-k}
		\end{column}
		
		\begin{column}{.6\textwidth}
			
			\begin{itemize}
				\item LRU-K
				\begin{itemize}
					
					\item LRU-K与LRU区别：LRU-K多了一个数据访问历史记录队列（需要注意的是，访问历史记录队列并不是缓存队列，所以是不保存数据本身的，只是保存对数据的访问记录），访问历史记录队列中维护着数据被访问的次数以及时间戳。
					\item 只有当这个数据被访问的次数大于等于K值时，才会从历史记录队列中删除，然后把数据加入到缓存队列中去。
					
				\end{itemize}
			\end{itemize}
			
			
		\end{column}
		
		
	\end{columns}
\end{frame}

%----------------------------------------------
\begin{frame}[plain]
	\frametitle{ }
	\begin{columns}
		\begin{column}{.4\textwidth}
			\centering
			%			\includegraphics[width=.6\textwidth]{mem-trash}
						\includegraphics[width=1.\textwidth]{lru-k}
		\end{column}
		
		\begin{column}{.6\textwidth}
			
			\begin{itemize}
				\item LRU-K
				\begin{itemize}
					
					\item 数据第一次被访问时，加入到历史访问记录队列中，访问次数为1，初始化访问时间戳；
					\item 如果数据访问次数没有达到K次，则访问次数+1，更新时间戳。当队列满了时，按照某种规则（LRU或者FIFO）将历史记录淘汰；%为了避免历史数据污染未来数据的问题，还需要加上一个有效期限，对超过有效期的访问记录，进行重新计数；
					\item 当访问历史队列中的数据访问次数达到K次后，将数据索引从历史队列删除，将数据移到缓存队列中，缓存队列重新按照时间排序；
					\item 缓存数据队列中被再次访问后，重新排序
					\item 需要淘汰数据时，淘汰缓存队列中排在末尾的数据，即：淘汰“倒数第K次访问离现在最久”的数据
					
					
				\end{itemize}
			\end{itemize}

			
		\end{column}
		
		
	\end{columns}
\end{frame}


%----------------------------------------------
\begin{frame}[plain]
	\frametitle{ }
	\begin{columns}
		\begin{column}{.4\textwidth}
			\centering
			%			\includegraphics[width=.6\textwidth]{mem-trash}
			\includegraphics[width=1.\textwidth]{lru-k}
		\end{column}
		
		\begin{column}{.6\textwidth}
			
			\begin{itemize}
				\item 评价 LRU-K 
				\begin{itemize}
					
					\item LRU-K降低了“缓存污染”带来的问题，命中率比LRU要高。
					\item 在实际应用中,LRU-2是综合各种因素后最优的选择。
					\item LRU-3或更大的K值命中率会高，但适应性差，一旦访问模式发生变化，需要大量的新数据访问才能将历史热点访问记录清除掉。
					\item LRU-K数据缓存队列一般是一个优先级队列。排序操作需要额外的O(logN)的时间复杂度，N为数据缓存队列的大小。
					
				\end{itemize}
			\end{itemize}
			\centering
			\large 从能否进一步改进？
		\end{column}
		
		
	\end{columns}
\end{frame}




%----------------------------------------------
\begin{frame}[plain]
	\frametitle{ }
	\begin{columns}
		\begin{column}{.4\textwidth}
			\centering
			%			\includegraphics[width=.6\textwidth]{mem-trash}
			\includegraphics[width=1.\textwidth]{2q}
		\end{column}
		
		\begin{column}{.6\textwidth}
			
			\begin{itemize}
				\item 2Q
				\begin{itemize}
					
					\item 2Q算法类似于LRU-2，不同点在于2Q将LRU-2算法中的访问历史队列（注意这不是缓存数据的）改为一个FIFO缓存队列，即：2Q算法有两个缓存队列，一个是FIFO队列（First in First out，先进先出），一个是LRU队列。
					\item 当数据第一次访问时，2Q算法将数据缓存在FIFO队列里面，当数据第二次被访问时，则将数据从FIFO队列移到LRU队列里面，两个队列各自按照自己的方法淘汰数据。
				\end{itemize}
			\end{itemize}
%			\centering
%			\large 从能否进一步改进？
		\end{column}
		
		
	\end{columns}
\end{frame}


%----------------------------------------------
\begin{frame}[plain]
	\frametitle{ }
	\begin{columns}
		\begin{column}{.4\textwidth}
			\centering
			%			\includegraphics[width=.6\textwidth]{mem-trash}
			\includegraphics[width=1.\textwidth]{2q}
		\end{column}
		
		\begin{column}{.6\textwidth}
			
			\begin{itemize}
				\item 2Q
				\begin{itemize}
					
					\item 新访问的数据先插入到FIFO队列中；
					\item 如果数据在FIFO队列中一直没有被再次访问，则最终按照FIFO规则淘汰；
					\item 如果数据在FIFO队列中被再次访问，则将数据从FIFO删除，加入到LRU队列头部；
					\item 如果数据在LRU队列再次被访问，则将数据移到LRU队列头部；
					\item LRU队列淘汰末尾的数据。
				\end{itemize}
			\end{itemize}

		\end{column}
		
		
	\end{columns}
\end{frame}



%----------------------------------------------
\begin{frame}[plain]
	\frametitle{ }
	\begin{columns}
		\begin{column}{.4\textwidth}
			\centering
			%			\includegraphics[width=.6\textwidth]{mem-trash}
			\includegraphics[width=1.\textwidth]{2q}
		\end{column}
		
		\begin{column}{.6\textwidth}
			
			\begin{itemize}
				\item 评价2Q
				\begin{itemize}
					\item 计算开销小于LRU-2
					\item 命中率与LRU-2类似，命中率要高于LRU
					\item 需要维护两个队列，代价是FIFO和LRU代价之和
					\item 仍然需要配置参数

				\end{itemize}
			\end{itemize}
						\centering
						\large 从能否进一步改进？
												
		\end{column}
		
		
	\end{columns}
\end{frame}

%----------------------------------------------
\begin{frame}[plain]
	\frametitle{ }
	\begin{columns}
		\begin{column}{.5\textwidth}
			\centering
			%			\includegraphics[width=.6\textwidth]{mem-trash}
			\includegraphics[width=1.\textwidth]{lirs}
			\includegraphics[width=.5\textwidth]{lirs-irr-r}
		\end{column}
		
		\begin{column}{.5\textwidth}
			LIRS (Low Inter-reference Recency Set)\textbf{}
%			\begin{itemize}
				
				\begin{itemize}
					\item Recency：最近被访问的时间。
					\item IRR(Inter-Reference Recency )：同一块连续两次访问期间中间访问过的不重复块数。
					\item  LIRS算法动态区分低IRR(LIR)和高IRR(HIR)的块，LIR块一般会常驻cache，HIR块则会较快被替换出cache。
					\item 基本思路：如果块的IRR值高，那么它的下一次IRR值也会很高，所以要替换IRR值高的块。
%					\item 要保证所有LIR块都能缓存，只有比例较小的Cache供HIR块缓存，当LIR块的Recency超过某个值，且HIR块在一个更小的Recency中被访问，两者的状态就会交换。

					
				\end{itemize}
%			\end{itemize}
%			\centering
%			\large 从能否进一步改进？
			
		\end{column}
		
		
	\end{columns}
\end{frame}


%----------------------------------------------
\begin{frame}[plain]
	\frametitle{ }
	\begin{columns}
		\begin{column}{.4\textwidth}
			\centering
			%			\includegraphics[width=.6\textwidth]{mem-trash}
				\includegraphics[width=1.\textwidth]{lirs-ex-map}
		\end{column}
		
		\begin{column}{.6\textwidth}
			LIRS 例子
			
		\includegraphics[width=1.\textwidth]{lirs-example}
			
		\end{column}
		
		
	\end{columns}
\end{frame}


%----------------------------------------------
\begin{frame}[plain]
	\frametitle{ }
	\begin{columns}
		\begin{column}{.4\textwidth}
			\centering
			%			\includegraphics[width=.6\textwidth]{mem-trash}
%			\includegraphics[width=1.\textwidth]{lirs}
			\includegraphics[width=1.\textwidth]{lirs-ex-map}
		\end{column}
		
		\begin{column}{.6\textwidth}
			LIRS 例子：D在时刻10被访问，替换哪个块？
			
			\includegraphics[width=1.\textwidth]{lirs-ex2}
			\pause
			\centering
			替换 HIR块 E	
		\end{column}
		
		
	\end{columns}
\end{frame}




%----------------------------------------------
\begin{frame}[plain]
	\frametitle{ }
	\begin{columns}
		\begin{column}{.4\textwidth}
			\centering
			%			\includegraphics[width=.6\textwidth]{mem-trash}
			%			\includegraphics[width=1.\textwidth]{lirs}
			\includegraphics[width=1.\textwidth]{lirs-ex-map}
		\end{column}
		
		\begin{column}{.6\textwidth}
			LIRS 例子：LIR Set如何更新？
			
			\includegraphics[width=1.\textwidth]{lirs-ex3}
			

		\end{column}
		
		
	\end{columns}
\end{frame}


%----------------------------------------------
\begin{frame}[plain]
	\frametitle{ }
	\begin{columns}
		\begin{column}{.4\textwidth}
			\centering
			%			\includegraphics[width=.6\textwidth]{mem-trash}
			%			\includegraphics[width=1.\textwidth]{lirs}
			\includegraphics[width=1.\textwidth]{lirs-ex-map}
		\end{column}
		
		\begin{column}{.6\textwidth}
			LIRS 例子：LIR Set如何更新？
			
			\includegraphics[width=1.\textwidth]{lirs-ex4}
			
			E被替换，D进入LIR Set，B进入LHR Set 
		\end{column}
		
		
	\end{columns}
\end{frame}


%----------------------------------------------
\begin{frame}[plain]
	\frametitle{ }
	\begin{columns}
		\begin{column}{.4\textwidth}
			\centering
			%			\includegraphics[width=.6\textwidth]{mem-trash}
			%			\includegraphics[width=1.\textwidth]{lirs}
			\includegraphics[width=1.\textwidth]{lirs-ex-map}
		\end{column}
		
		\begin{column}{.6\textwidth}
			LIRS 例子：C在时刻10被访问，替换哪个块？如何更新LIR/LHR Set？
			
			\includegraphics[width=1.\textwidth]{lirs-ex5}
			
			\pause
			\centering
			E被替换，C不能进入LIR块集合 
		\end{column}
		
		
	\end{columns}
\end{frame}


%----------------------------------------------
\begin{frame}[plain]
	\frametitle{ }
	\begin{columns}
		\begin{column}{.5\textwidth}
			\centering
			%			\includegraphics[width=.6\textwidth]{mem-trash}
			\includegraphics[width=.8\textwidth]{lirs-ex3}
			
			E被换掉，D与B的状态进行了交换 
			
			\includegraphics[width=.8\textwidth]{lirs-ex4}
		\end{column}
		
		\begin{column}{.5\textwidth}
			LIRS 替换策略
			%			\begin{itemize}
			
			\begin{itemize}

				\item  LIR块一般会常驻cache，HIR块则会较快被替换出cache。通常假设LIR占99\%的cache大小，HIR占1\%即可。 
				\item 如果块的IRR值高，那么它的下一次IRR值也会很高，所以要替换IRR值高的块。
				\item 要保证所有LIR块都能缓存，当LIR块的Recency超过IRR最大值，且HIR块在一个更小的Recency中被访问，两者的状态就会交换。
				
				
			\end{itemize}
			%			\end{itemize}
			%			\centering
			%			\large 从能否进一步改进？
			
		\end{column}
		
		
	\end{columns}
\end{frame}




%----------------------------------------------
\begin{frame}[plain]
	\frametitle{ }
	\begin{columns}
		\begin{column}{.5\textwidth}
			\centering
			%			\includegraphics[width=.6\textwidth]{mem-trash}
			\includegraphics[width=.8\textwidth]{lirs-stack}
			
		\end{column}
		
		\begin{column}{.5\textwidth}
			LIRS 替换算法
			%			\begin{itemize}
			
			\begin{itemize}
				\item Stack S:  包括LIR块、少于LIR块最大recency的HIR块
				\item Stack Q:  HIR块FIFO缓存队列(加快HIR块缓存的搜索)

				\item “栈裁剪”操作，栈S的底部LIR块被删除，则一直删除底部块直到遇到另一个LIR块。这样做的目的是因为如果底部存在HIR块，则这些HIR块必定大于LIR块的最大recency，这样它们肯定不能转变为LIR块。
				
				
			\end{itemize}
			%			\end{itemize}
			%			\centering
			%			\large 从能否进一步改进？
			
		\end{column}
		
		
	\end{columns}
\end{frame}


%----------------------------------------------
\begin{frame}[plain]
	\frametitle{ }
	\begin{columns}
		\begin{column}{.1\textwidth}
			\centering
			%			\includegraphics[width=.6\textwidth]{mem-trash}
%			\includegraphics[width=.8\textwidth]{lirs-stack-hit}
			
		\end{column}
		
		\begin{column}{.9\textwidth}
			LIRS 替换算法 (LIR hit)
			%			\begin{itemize}
			
			\begin{itemize}
				\item 访问栈S中的LIR块X：LIR块必定驻cache中，所以必定命中缓存。然后把块X移动到栈S的头部，如果块X之前是在栈S的底部，则执行“栈裁剪”操作。
				
%				\item 访问驻cache中的HIR块X：访问命中缓存。把X移动到栈S头部。另外块X有两种情况：(1)块X在栈S中，把它状态转换为LIR，还删除队列Q中块X的cache。然后把栈S底部的LIR块转换为HIR块，然后移动到队列Q中。最后“栈裁剪”。(2)块X不在栈S中，则块X的状态保持HIR不变，然后从队列Q的cache移动到队列尾部。
%				
%				\item 访问非驻cache中的HIR块X：没有命中缓存。首先删除队列Q头部的HIR块（如果该块在栈S，则变为非驻cache状态），这样多出cache空间，然后加载块X到该cache空间，然后移动到栈S的顶部。块X同样有两种情况：(1)块X在栈S中，改变状态为LIR，并同时改变栈底部的LIR块为HIR块，并移动到队列Q的尾部，然后“栈裁剪”。(2)块X不在栈S中，则状态为HIR，并放到队列Q的尾部。
			
				
				
			\end{itemize}
			\centering
             \includegraphics[width=.8\textwidth]{lirs-stack-hit}
			
		\end{column}
		
		
	\end{columns}
从\end{frame}


%----------------------------------------------
\begin{frame}[plain]
	\frametitle{ }
	\begin{columns}
		\begin{column}{.1\textwidth}
			\centering
			%			\includegraphics[width=.6\textwidth]{mem-trash}

			
		\end{column}
		
		\begin{column}{.9\textwidth}
			LIRS 替换算法 (HIR hit)
			%			\begin{itemize}
			
			\begin{itemize}
%				\item 访问栈S中的LIR块X：LIR块必定驻cache中，所以必定命中缓存。然后把块X移动到栈S的头部，如果块X之前是在栈S的底部，则执行“栈裁剪”操作。
				
			\item 访问驻cache中的HIR块X，把X移动到栈S头部，有两种情况：
%			\begin{itemize}
				\item 在S中，X状态转换为LIR，删除Q中X的cache，把S底部的LIR块转为HIR块，移动到Q中，最后“栈裁剪”。
				\item 不在S中，则X状态保持HIR，从队列Q中移动到Q头部。
				%				
				%				\item 访问非驻cache中的HIR块X：没有命中缓存。首先删除队列Q头部的HIR块（如果该块在栈S，则变为非驻cache状态），这样多出cache空间，然后加载块X到该cache空间，然后移动到栈S的顶部。块X同样有两种情况：(1)块X在栈S中，改变状态为LIR，并同时改变栈底部的LIR块为HIR块，并移动到队列Q的尾部，然后“栈裁剪”。(2)块X不在栈S中，则状态为HIR，并放到队列Q的尾部。
				
%			\end{itemize}	
				
			\end{itemize}
			\centering
			 \includegraphics[width=.8\textwidth]{lirs-stack-hir-hit}
			
		\end{column}
		
		
	\end{columns}
\end{frame}




%----------------------------------------------
\begin{frame}[plain]
	\frametitle{ }
	\begin{columns}
		\begin{column}{.1\textwidth}
			\centering
			%			\includegraphics[width=.6\textwidth]{mem-trash}
			
			
		\end{column}
		
		\begin{column}{.9\textwidth}
			LIRS 替换算法 (Missing)
			%			\begin{itemize}
			
			\begin{itemize}
%				\item 访问栈S中的LIR块X：LIR块必定驻cache中，所以必定命中缓存。然后把块X移动到栈S的头部，如果块X之前是在栈S的底部，则执行“栈裁剪”操作。
				
%								\item 访问驻cache中的HIR块X：访问命中缓存。把X移动到栈S头部。另外块X有两种情况：(1)块X在栈S中，把它状态转换为LIR，还删除队列Q中块X的cache。然后把栈S底部的LIR块转换为HIR块，然后移动到队列Q中。最后“栈裁剪”。(2)块X不在栈S中，则块X的状态保持HIR不变，然后从队列Q的cache移动到队列尾部。
				%				
				\item 访问非驻留的HIR块X。删除Q尾部的HIR块，如果该块在栈S，则变为非驻留状态，加载块X，把X移动到栈S的顶部。有两种情况：
				\begin{itemize}
%					\item (1)块X在栈S中，改变状态为LIR，并同时改变栈底部的LIR块为HIR块，并移动到队列Q的尾部，然后“栈裁剪”。
					\item 块X不在栈S中，则状态为HIR，并放到队列Q的头部。
				
				
			\end{itemize}
			\end{itemize}
			\centering
			\includegraphics[width=.8\textwidth]{lirs-stack-miss-1}
			
		\end{column}
		
		
	\end{columns}
\end{frame}


%----------------------------------------------
\begin{frame}[plain]
	\frametitle{ }
	\begin{columns}
		\begin{column}{.1\textwidth}
			\centering
			%			\includegraphics[width=.6\textwidth]{mem-trash}
			
			
		\end{column}
		
		\begin{column}{.9\textwidth}
			LIRS 替换算法 (Missing)
			%			\begin{itemize}
			
			\begin{itemize}
				%				\item 访问栈S中的LIR块X：LIR块必定驻cache中，所以必定命中缓存。然后把块X移动到栈S的头部，如果块X之前是在栈S的底部，则执行“栈裁剪”操作。
				
				%								\item 访问驻cache中的HIR块X：访问命中缓存。把X移动到栈S头部。另外块X有两种情况：(1)块X在栈S中，把它状态转换为LIR，还删除队列Q中块X的cache。然后把栈S底部的LIR块转换为HIR块，然后移动到队列Q中。最后“栈裁剪”。(2)块X不在栈S中，则块X的状态保持HIR不变，然后从队列Q的cache移动到队列尾部。
				%				
				\item 访问非驻留的HIR块X。删除Q尾部的HIR块，如果该块在栈S，则变为非驻留状态，加载块X，把X移动到栈S的顶部。有两种情况：
				\begin{itemize}
				 \item 块X在栈S中，改变状态为LIR，并同时改变栈底部的LIR块为HIR块，并移动到队列Q的头部，然后“栈裁剪”。
%					\item 块X不在栈S中，则状态为HIR，并放到队列Q的头部。
					
					
				\end{itemize}
			\end{itemize}
			\centering
			\includegraphics[width=.8\textwidth]{lirs-stack-missing-2}
			
		\end{column}
		
		
	\end{columns}
\end{frame}


%----------------------------------------------
\begin{frame}[plain]
	\frametitle{ }
	\begin{columns}
		\begin{column}{.3\textwidth}
			\centering
			%			\includegraphics[width=.6\textwidth]{mem-trash}
			\includegraphics[width=.8\textwidth]{lirs}
			\includegraphics[width=.6\textwidth]{lirs-balance}
		\end{column}
		
		\begin{column}{.6\textwidth}
			
			\begin{itemize}
				\item 评价LIRS
				\begin{itemize}
					\item LIRS能够快速适应上述4种访问模式。
					\item 特别对于循环访问，LIRS能够固定开始的LIR块驻cache中，保证了cache命中率。
					\item LIRS不像2Q等需要设置过多参数。
					\item 实现的复杂度类似LRU。
					\item  从性能角度来看，LIRS>2Q>LRU-K>LRU
					
				\end{itemize}
			\end{itemize}
			\centering
			\large 从能否进一步改进？(Your Work)
			
		\end{column}
		
		
	\end{columns}
\end{frame}

%----------------------------------------------------------------------------------------

\end{document}
