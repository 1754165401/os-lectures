\input{../preamble}

%----------------------------------------------------------------------------------------
% TITLE PAGE
%----------------------------------------------------------------------------------------

\title[第19讲]{第二十讲 ：分布式系统} % The short title appears at the bottom of every slide, the full title is only on the title page
\subtitle{第1节：分布式系统概述}
\author{向勇、陈渝、李国良} % Your name
\institute[清华大学] % Your institution as it will appear on the bottom of every slide, may be shorthand to save space
{
    清华大学计算机系 \\ % Your institution for the title page
    \medskip
    \textit{xyong,yuchen,liguoliang@tsinghua.edu.cn} % Your email address
}
\date{\today} % Date, can be changed to a custom date

\begin{document}
    
    \begin{frame}
        \titlepage % Print the title page as the first slide
    \end{frame}
    
    %----------------------------------------------
    \begin{frame}
        \frametitle{提纲} % Table of contents slide, comment this block out to remove it
        \tableofcontents % Throughout your presentation, if you choose to use \section{} and \subsection{} commands, these will automatically be printed on this slide as an overview of your presentation
        
        %% itemize
        %Ref:
        %    \begin{itemize}
        %        \item \href{http://osq.cs.berkeley.edu/public/JFoster-Drivers.ppt}{Linux Device Drivers Overview}
        %        \item \href{http://ermak.cs.nstu.ru/understanding.linux.kernel.pdf}{Understanding the Linux Kernel}
        %    \end{itemize}
        
    \end{frame}
    %----------------------------------------------
    %%  PRESENTATION SLIDES
    %----------------------------------------------
    \section{第1节：分布式系统概述} % Sections can be created in order to organize your presentation into discrete blocks, all sections and subsections are automatically printed in the table of contents as an overview of the talk
    %----------------------------------------------
    \subsection{通信基础} % A subsection can be created just before a set of slides with a common theme to further break down your presentation into chunks
    %----------------------------------------------
    \begin{frame}[fragile]
        \frametitle{通信基础}
        分布式系统改变了世界的面貌
        
        关键问题：  如何构建在组件故障时仍能工作的系统　
        
        
        
        %    \framesubtitle{xxxx}
        %% figure
            \begin{figure}
            \includegraphics[width=0.8\linewidth]{figs/distributed.png}
          %  \caption{xxxx}
            \end{figure}
    \end{frame}
%----------------------------------------------
\begin{frame}[fragile]
    \frametitle{通信基础}
    %    \framesubtitle{xxxx}
    不可靠的通信层
    \begin{itemize}
        \item 现代网络的核心原则是，通信基本是不可靠的。
        \item 丢包是网络的基本现象
        \item 应该如何处理丢包？
    \end{itemize}
    %    \begin{figure}
    %        \includegraphics[width=0.3\linewidth]{figs/u740-arch.png}
    %        %  \caption{xxxx}
    %    \end{figure}
\end{frame}
%----------------------------------------------
\begin{frame}[fragile]
    \frametitle{通信基础}
%    \framesubtitle{xxxx}
一个基于UDP/IP构建的简单客户端和服务器
            \begin{figure}
    \includegraphics[width=1.\linewidth]{figs/udp-client.png}
    %  \caption{xxxx}
\end{figure}
\end{frame}

%----------------------------------------------
\begin{frame}[fragile]
    \frametitle{通信基础}
    %    \framesubtitle{xxxx}
    一个基于UDP/IP构建的简单客户端和服务器
    \begin{figure}
        \includegraphics[width=0.8\linewidth]{figs/udp-server.png}
        %  \caption{xxxx}
    \end{figure}
\end{frame}
%----------------------------------------------
%----------------------------------------------
\begin{frame}[fragile]
    \frametitle{可靠的通信层}
    %    \framesubtitle{xxxx}
    问题：发送方如何知道接收方实际收到了消息？ 
    \begin{itemize}
        \item 确认（acknowledgment），或简称为ack
        \item     发送方向接收方发送消息，接收方然后发回短消息确认收到
    \end{itemize}
    
    \begin{figure}
        \includegraphics[width=0.8\linewidth]{figs/ack.png}
        \caption{消息加确认}
    \end{figure}
\end{frame}
%----------------------------------------------
\begin{frame}[fragile]
    \frametitle{可靠的通信层}
    %    \framesubtitle{xxxx}
    问题：如果没有收到确认，发送方应该怎么办？
    \begin{itemize}
        \item 额外的机制，称为超时（timeout） + 重试（retry）
        \item  当发送方发送消息后，如在一定时间内未收到确认，则断定该消息已丢失
        \item  发送方然后就重试（retry）发送，再次发送相同的消息，希望这次它能送达
    \end{itemize}

    \begin{figure}
        \includegraphics[width=0.4\linewidth]{figs/timeout.png}
          \caption{消息加确认：丢失的请求}
    \end{figure}
\end{frame}


%----------------------------------------------
\begin{frame}[fragile]
    \frametitle{可靠的通信层}
    %    \framesubtitle{xxxx}
    问题：如果没有收到确认，发送方应该怎么办？
    \begin{itemize}
        \item 额外的机制，称为超时（timeout） + 重试（retry）
        \item  当发送方发送消息后，如在一定时间内未收到确认，则断定该消息已丢失
        \item  发送方然后就重试（retry）发送，再次发送相同的消息，希望这次它能送达
    \end{itemize}
    
    \begin{figure}
        \includegraphics[width=0.35\linewidth]{figs/timeout-answer.png}
        \caption{消息加确认：丢失回答}
    \end{figure}
\end{frame}
%----------------------------------------------

%----------------------------------------------
\begin{frame}[fragile]
    \frametitle{可靠的通信层}
    %    \framesubtitle{xxxx}
    问题：如何保证接收方每个消息只接收一次（exactly once）？
    \begin{itemize}
        \item 发送方可以为每条消息生成唯一的ID，接收方可以追踪它所见过的每个ID
        \item  顺序计数器（sequence counter）
            \begin{itemize}
            \item 无论何时发送消息，计数器的当前值都与消息一起发送。此计数器值（N）作为消息的ID。发送消息后，发送方递增该值（到N + 1）。
            \item 接收方使用其计数器值，作为发送方传入消息的ID的预期值。如果接收的消息（N）的ID与接收方的计数器匹配（也是N），它将确认该消息，将其传递给上层的应用程序。在这种情况下，接收方断定这是第一次收到此消息。接收方然后递增其计数器（到N + 1），并等待下一条消息。
            \item 如果确认丢失，则发送方将超时，并重新发送消息N。这次，接收器的计数器更高（N+1），因此接收器知道它已经接收到该消息。因此它会确认该消息，但不会将其传递给应用程序。
            \end{itemize}
    \end{itemize}
    
%    \begin{figure}
%        \includegraphics[width=0.35\linewidth]{figs/timeout-answer.png}
%        \caption{消息加确认：丢失回答}
%    \end{figure}
\end{frame}

%----------------------------------------------
\begin{frame}[fragile]
    \frametitle{通信抽象}
    %    \framesubtitle{xxxx}
    问题：有了基本的消息传递层，在构建分布式系统时，应该使用什么抽象通信？
    \begin{itemize}
        \item 操作系统抽象：分布式共享内存（Distributed Shared Memory，DSM）
                    \begin{itemize}
            \item 使不同机器上的进程能够共享一个大的虚拟地址空间
            \item 通过操作系统的虚拟内存系统来实现
            \item DSM最大的问题是它如何处理故障
            \item 另一个问题是性能
            \item 这种方法今天并未广泛使用
        \end{itemize}
    \end{itemize}
    
%    \begin{figure}
%        \includegraphics[width=0.35\linewidth]{figs/timeout-answer.png}
%        \caption{消息加确认：丢失回答}
%    \end{figure}
\end{frame}

%----------------------------------------------
\begin{frame}[fragile]
    \frametitle{通信抽象}
    %    \framesubtitle{xxxx}
    问题：有了基本的消息传递层，在构建分布式系统时，应该使用什么抽象通信？
    \begin{itemize}
        \item 编程语言（PL）抽象：远程过程调用（Remote Procedure Call），或简称RPC
        \begin{itemize}
            \item 目标：使在远程机器上执行代码的过程像调用本地函数一样简单直接。
            \item RPC系统通常有两部分：存根生成器（stub generator，有时称为协议编译器，protocol compiler）和运行时库（run-time library）。
        \end{itemize}
    \end{itemize}
    
    %    \begin{figure}
    %        \includegraphics[width=0.35\linewidth]{figs/timeout-answer.png}
    %        \caption{消息加确认：丢失回答}
    %    \end{figure}
\end{frame}

%----------------------------------------------
\begin{frame}[fragile]
    \frametitle{通信抽象 -- 存根生成器}
    %    \framesubtitle{xxxx}
    存根生成器(Stub Generator)：    存根生成器接受接口(interface)代码，并生成客户端存根（client stub）和服务端代理(server proxy)
    
    客户端存根（client stub）
    \begin{itemize}
        \item 创建消息缓冲区;将所需信息打包到消息缓冲区中;
        \item 将消息发送到目标RPC服务器;等待回复;
        \item 解包返回代码和其他参数;返回调用函数。

    \end{itemize}
    
        \begin{figure}
            \includegraphics[width=0.6\linewidth]{figs/rpc-interface.png}
%            \caption{消息加确认：丢失回答}
        \end{figure}
\end{frame}

%----------------------------------------------
\begin{frame}[fragile]
    \frametitle{通信抽象 -- 存根生成器}
    %    \framesubtitle{xxxx}
    存根生成器(Stub Generator)：    存根生成器接受接口(interface)代码，并生成客户端存根（client stub）和服务端代理(server proxy)
    
    服务端代理(server proxy)
    \begin{itemize}
        \item 解包消息;
        \item 调用实际函数;
        \item 打包结果；发送回复。
        
    \end{itemize}
    
    \begin{figure}
        \includegraphics[width=0.6\linewidth]{figs/rpc-interface.png}
        %            \caption{消息加确认：丢失回答}
    \end{figure}
\end{frame}

%----------------------------------------------
\begin{frame}[fragile]
    \frametitle{通信抽象 -- 运行时库}
    %    \framesubtitle{xxxx}
    运行时库处理RPC系统中的大部分繁重工作
  
    \begin{itemize}
        \item 如何找到远程服务？
        \item 如何构建RPC的传输级协议？        
    \end{itemize}
    
    \begin{figure}
        \includegraphics[width=0.6\linewidth]{figs/rpc-interface.png}
        %            \caption{消息加确认：丢失回答}
    \end{figure}
\end{frame}
%----------------------------------------------
\begin{frame}[fragile]
    \frametitle{通信抽象 -- 需思考的问题}
    %    \framesubtitle{xxxx}
    值得进一步思考的问题
    \begin{itemize}
        \item 调用中的复杂参数，即一个包如何发送复杂的数据结构？
        \item 并发性的服务器组织方式？
        \item 当远程调用需要很长时间才能完成时，会发生什么？
        \item 是否向客户端暴露通信的异步性质，从而实现一些性能优化？
    \end{itemize}
    
    \begin{figure}
        \includegraphics[width=0.6\linewidth]{figs/rpc-interface.png}
        %            \caption{消息加确认：丢失回答}
    \end{figure}
\end{frame}
%----------------------------------------------
\end{document}
