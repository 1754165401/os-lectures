\input{../preamble}

%----------------------------------------------------------------------------------------
% TITLE PAGE
%----------------------------------------------------------------------------------------

\title[第21讲]{第二十一讲 ：异步编程(Asynchronous Programming)} % The short title appears at the bottom of every slide, the full title is only on the title page
\subtitle{第3节：Generators and async/await}
\author{向勇、陈渝} % Your name
\institute[清华大学] % Your institution as it will appear on the bottom of every slide, may be shorthand to save space
{
  清华大学计算机系 \\ % Your institution for the title page
  \medskip
  \textit{xyong,yuchen@tsinghua.edu.cn} % Your email address
}
\date{\today} % Date, can be changed to a custom date

\begin{document}

\begin{frame}
\titlepage % Print the title page as the first slide
\end{frame}

%----------------------------------------------
\begin{frame}
\frametitle{提纲} % Table of contents slide, comment this block out to remove it
\tableofcontents % Throughout your presentation, if you choose to use \section{} and \subsection{} commands, these will automatically be printed on this slide as an overview of your presentation

%% itemize
Ref:
    \begin{itemize}
        \item \href{}{xxxx}
    \end{itemize}

\end{frame}
%----------------------------------------------
%%  PRESENTATION SLIDES
%----------------------------------------------
\section{第3节：Generators and async/await} % Sections can be created in order to organize your presentation into discrete blocks, all sections and subsections are automatically printed in the table of contents as an overview of the talk
%----------------------------------------------
\subsection{xxxx} % A subsection can be created just before a set of slides with a common theme to further break down your presentation into chunks
%----------------------------------------------
\begin{frame}[fragile]
    \frametitle{xxxx}
%    \framesubtitle{xxxx}
\end{frame}
%----------------------------------------------
% ### 21.3 Generators and async/await
% 
% Ref: https://cfsamson.github.io/books-futures-explained/3_generators_async_await.html#generators-and-asyncawait
% 
% #### Concurrency in Rust
% 
% Ref: https://cfsamson.github.io/books-futures-explained/3_generators_async_await.html
% 
% 1. Stackful coroutines, better known as green threads.
% 2. Using combinators.
% 3. Stackless coroutines, better known as generators.
% 
% #### State Machine Transformation in Future
% 
% Ref: https://os.phil-opp.com/async-await/#state-machine-transformation
% https://cfsamson.github.io/books-futures-explained/3_generators_async_await.html#stackless-coroutinesgenerators
% 
% - Async in Rust is implemented using Generators
% - Generators in Rust are implemented as state machines
% - Compiler transforms the body of the `async` function into a [*state machine*](https://en.wikipedia.org/wiki/Finite-state_machine), with each `.await` call representing a different state.
% - Each state represents a different pause point of the function
% 
% ![async-state-machine-states](figs/async-state-machine-states.svg)
% 
% - Arrows represent state switches and diamond shapes represent alternative ways
% 
% ![async-state-machine-basic](figs/async-state-machine-basic.svg)
% 
% #### State Machine Type
% 
% Ref: https://os.phil-opp.com/async-await/#the-full-state-machine-type
% 
% - Create a state machine and combine them into an [`enum`](https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html)
% 
% ```rust
% enum ExampleStateMachine {
%     Start(StartState),
%     WaitingOnFooTxt(WaitingOnFooTxtState),
%     WaitingOnBarTxt(WaitingOnBarTxtState),
%     End(EndState),
% }
% ```
% 
% - Generates an implementation of the state transitions in the `poll` function
% 
% ```rust
% impl Future for ExampleStateMachine {
%     type Output = String; // return type of `example`
% 
%     fn poll(self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {
%         loop {
%             match self { // TODO: handle pinning
%                 ExampleStateMachine::Start(state) => {…}
%                 ExampleStateMachine::WaitingOnFooTxt(state) => {…}
%                 ExampleStateMachine::WaitingOnBarTxt(state) => {…}
%                 ExampleStateMachine::End(state) => {…}
%             }
%         }
%     }
% }
% ```
% 
% #### Example of Generator
% 
% Ref: https://cfsamson.github.io/books-futures-explained/3_generators_async_await.html#how-generators-work
% 
% ```rust
% #![feature(generators, generator_trait)]
% use std::ops::{Generator, GeneratorState};
% 
% fn main() {
%     let a: i32 = 4;
%     let mut gen = move || {
%         println!("Hello");
%         yield a * 2;
%         println!("world!");
%     };
% 
%     if let GeneratorState::Yielded(n) = gen.resume() {
%         println!("Got value {}", n);
%     }
% 
%     if let GeneratorState::Complete(()) = gen.resume() {
%         ()
%     };
% }
% ```
% 
%----------------------------------------------
\end{document}
