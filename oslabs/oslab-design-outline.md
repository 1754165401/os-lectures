# 2021-01-12更新：

添加可能的实验设计思路。尝试把吴一凡完成的ch1~ch7的实验过程进行拆分，形成从最低点hellworld向上的包含2~3个点的不同OS实现路线：

helloworld->exception，helloworld->interrupt，helloworld->syscall，helloworld-->task， helloworld-->phymem-info，helloworld-->heap-alloc，hellowold-->frame-alloc，helloworld-->paging，helloworld-->easy-fs

# 2021-01-04更新：

Chaptter4 添加实现的过程描述：改进内存隔离的好处；

# 2020-12-20更新：

将文件描述符从 Chapter7 移动到 Chapter6。

# 2020-12-02更新：

根据讨论更新了 Chapter1-Chapter7 到分割线之前的内容作为 Tutorial 的第一部分，即让系统能够将所有的资源都利用起来。第二部分则讨论如何做的更好。在 12 月 26 日之前尽可能按照大纲完成多个不同版本的 demo。

[https://shimo.im/sheets/wV3VVxl04EieK3y1/MODOC](https://shimo.im/sheets/wV3VVxl04EieK3y1/MODOC)是目前的系统调用一览表，预计只需要实现 14 个系统调用就能初步满足要求。

# 2020-11-30更新：

更新了Chapter2。

合并了Chapter3/Chapter4为Chapter3，目前覆盖范围为Chapter1-Chapter5。

# 2021-11-01更新：
与dzy，jyk讨论，形成实验大纲初稿，见附录D。

# 2020-10-11更新：

与wyf讨论，形成tutorial代码框架完善计划，见附录E。

# lab 设计：2020-11-01

## 可能的实验设计思路

* 实验过程或节点的分离性、可组合性和重用性
    * 实验过程中的所有路径集合形成了一个数学上的格状（或具有上下层次关系的网状）结构。格的下界点（网的最低点）是“显示helloworld”的最弱OS；格的上界点（网的最高点）是“显示helloworld”的“具有基本ucore功能”的完整的类UNIX OS；格中不同层次有连线的点具有某种上下依赖关系（即格的偏序,即实现上具有先后关系），没有连线的点不具有某种上下依赖关系（即实现上没有先后关系）。有些点的内核功能是下层的点的组合或改进的组合，可以形成一个crate，并被高层的点合并或组合。
    * 学生完成实验的过程，其实就是通过某条由合理的点集构成的路径（点集构成的线）实现从一个最低点“显示helloworld”的最弱OS逐步到达最高点“具有基本ucore功能”的完整类UNIX OS的。这条线中，从最低点开始的每个线段形成了一个特定功能的OS。
    * 部分具有一定可重用的点形成crate，并被学生以搭积木的形式重用或改造形成新的OS。
* 实验过程中OS模块的用户态特性、可调试性和自动测试服务
    * 为了让学生实习的OS内核模块（不用修改）的90%以上都能在用户态运行，100%能在内核态运行，需要设计形成OS模块执行所需的用户态执行环境（user execution environment）和内核态执行环境（supervisor execution environment）。这样带了的好处是，学生可以充分利用已经熟悉的IDE环境进行程序开发和调试。并能以比较小的代价完成实验。
    * 在内核态支持gdb命令行方式的debug，这样学生能进行调试。（目前还不知如何做到支持IDE级的调试）
    * 在内核态支持panic的backtrace调用栈显示，这样学生比较清楚问题出在哪里。
    * 改进QEMU或直接修改terminus模拟器，更好地提供程序崩溃的帮助提示或Debug能力。
    * 提供在线自动测试服务功能，基本功能是学生一提交commit到git server上，自动测试服务就会启动，完成基于测试用例等的自动测试，并在线/email给出测试结果
* 实验步骤设计
        * 修复bug：提供相对完整的step by step的一条线，学生可以看到开发的全过程。但线中的某些点（代表进行到的某些阶段）有bug，需要学生分析并fix bug。
        * 完成新的线：提供相对完整的step by step的一条线，学生可以参考这条线，重新完成一条新的实验路线。
        * 改进或形成新的点：学生根据要求，完成具有一定完整功能的crate或mod，并形成新的OS，在功能，性能，可靠性等方面比早期修复bug后的OS要性能强，功能多，更可靠。
        * 扩展实验：如果完成上述内容后，还有新想法，推荐做zcore扩展实验，代替考试。
* 实验的后备备份：如果寒假完成不了新实验，只好采用2020年春季的rcore tutorial for rv64 和 ucore for rv64
## 可能的章节与代码风格

* 新 OS 实验的目的是：“**强化学生对 OS 的整体观念**”。OS的目的是满足应用需求，为此需要一定的硬件支持和自身逐步增强的功能。鼓励学生自己从头写（有参考实现）、强化整体观、step-by-step。
* **整个文档的风格是应用**导向的，每个 step 的任务一定不是凭空而来、而是**应用**的需求。每一章都是为了解决一个应用具体需求而要求OS要完成的功能，这个功能需要一定的硬件支持。
* 每个章节给出完整可运行且带有完整注释（可以通过 rustdoc 工具生成 html 版）的代码。
* 文档中给出重要的代码片段（照顾到纸质版的读者，事实上在网页版给出代码的链接即可）而并不需要完整的代码，但是需要有完整的执行流程叙述，对于边界条件有足够的讨论。在文档中插入的代码不带有注释，而是将解释放到文档的文字部分。
* 类似xv6，每一章的小节描述一项小功能是如何实现的，不同小节之间可能有一定的先后关系，也有可能是并列的。
* 尽可能讲清楚设计背后的思想与优缺点。
* 在讲解OS设计方面，尽量做到与语言无关。在讲解例子的时候，应该有对应的C和rust版本。
* 在某些具体例子中，最好能体现rust比c强
* 2020-10-28：前几章 Chapter1-4 需要等具体实现出来之后再规划章节。
## Chapter0 Hello world! 之旅（偏教材）

### 主要动机：

参考 csapp 第一章，站在一个相对宏观的视角解释一个非常简单的 hello world! 程序是在哪些硬件/软件的支持下得以编译/运行起来的。

helloworld.c 如何被编译器编译成执行程序，且如何被操作系统执行的。

gcc

strace

## Chapter1 裸机应用（优先级1）

### 主要动机

支持应用进行计算与结果输出。

在裸机上输出 Hello world，就像在其他 OS 上一样。

app列表：

* hello_world：输出字符串
* count_sum：累加一维数组的和，并输出结果

备注：不需要输入功能

### 内核应完成功能

内存地址空间：

知道自己在内存的哪个位置。理解编译器生成的代码。

init：基本初始化

主要是硬件加电后的硬件初始化，以前是OS做，后面给BIOS, bootloader等完成初步初始化。OS需要知道内存大小，IO分布。

write函数：输出字符串

驱动串口的初始化，能够通过串口输出。

exit函数：表明程序结束

其它（不是主要的）：

在 qemu/k210 平台上基于 RustSBI 跳转到内核，打印调试信息，支持内核堆内存分配。

### 章节分布

基本上和第二版/第三版一致。注意需要考虑上面的应用和功能。

## Chapter2批处理系统（优先级1）

### 主要动机

内核不会被应用程序破坏

### 用户程序

支持应用进行计算与结果输出。在裸机上输出 Hello world，就像在其他 OS 上一样。但应用程序无法破坏内核，但能得到内核的服务。

app列表：

* hello_world：输出字符串。
* count_sum：累加一维数组的和，并输出结果。
### 内核应完成功能

设置好内核和用户运行的栈，内核初始化完成后通过 sret 跳转到用户程序进行执行，然后在用户程序系统调用的时候完成特权级切换、上下文保存/恢复及栈的切换

按顺序加载运行多个应用程序。当应用程序出错（非法指令基于 RustSBI 不容易完成，比如访问非法的物理地址）之后直接杀死应用程序并切换到下一个。

### 新增系统调用

* sys_write：向串口写
* sys_exit： 表明任务结束。
### 实现备注

将编译之后的用户镜像和内核打包到一起放到内存上

分离用户和内核特权级，保护OS，用户需要请求内核提供的服务

## 
## Chapter3 分时多任务系统之一非抢占式调度（优先级1）

### 主要动机

提高整个应用的CPU利用率

多任务，因此需要实现任务切换，可采用如下方法：

* 批处理：在内存中放多个程序，执行完一个再执行下一个。当执行IO操作时，采用的是忙等的方式，效率差。
* 非抢占切换：CPU和I/O设备之间速度不匹配矛盾，程序之间的公平性。当一个程序主动要求暂停或退出时，换另外一个程序执行CPU计算。

*>> 这时，可能需要引入中断（但中断不是本章主要的内容，如果不引入更好）。*

### 用户程序

两个程序放置在一个不同的固定的物理地址上（这样不需要页表机制等虚存能力），完成的功能为：一个程序完成一些计算&输出，主动暂停，OS切换到另外一个程序执行，交替运行。

* count_multiplication：一维数组的乘法，并输出结果
* count_sum：累加一维数组的和，并输出结果
* [wyf 的具体实现]三个输出小程序，详见[here](https://github.com/rcore-os/rCore-Tutorial-v3/tree/ch3-coop/user/src/bin)
### 内核应完成功能

实现通过 sys_yield 交出当前任务的 CPU 所有权，通过 sys_exit 表明任务结束。需要为每个任务分配一个用户栈和内核栈，且需要实现类似 switch 用来任务切换的函数。

* sys_yield：让出CPU
* sys_exit：退出当前任务并让出 CPU
### 实现备注

重点是实现switch

当所有任务运行结束后退出内核

## Chapter3 分时多任务系统之二 抢占式调度（优先级1）

### 主要动机

进一步提高整个应用的CPU利用率/交互性与任务之间的公平性

因此需要实现强制任务切换，并引入中断，可采用如下方法：

* 时钟中断：基于时间片进行调度
* （不在这里引入）串口中断：在发出输出请求后，不是轮询忙等，而是中断方式响应
### 用户程序

* [wyf 的具体实现]三个计算质数幂次的小程序，外加一个 sleep 的程序。[here](https://github.com/rcore-os/rCore-Tutorial-v3/tree/ch3/user/src/bin)
### 内核应完成功能

实现时钟/串口中断处理，以及基于中断的基本时间片轮转调度

### 新增系统调用

* sys_get_time：返回当前的 CPU 时钟周期数
## Chapter4 内存隔离安全性：地址空间（优先级1）

### 主要动机

* 更好地支持应用（包括内核）的动态内存需求。首先：在内核态实现动态内存分配（这是物理内存），这样引入了堆的概念
* 更好地支持在内核中对非法地址的访问的检查。在内核态实现页表机制，这样内核访问异常地址也能及时报警。
* 提高应用间的安全性（通过页机制实现隔离）
* 附带好处：应用程序地址空间可以相同，便于应用程序的开发
### 用户程序

应用程序与上一章基本相同，只不过应用程序的地址空间起始位置应该相同。而且这一章需要将 ELF 链接进内核而不是二进制镜像。

特别的，可以设置访问其他应用程序地址空间或是访问内核地址空间的应用程序，内核会将其杀死。

在用户库使用 sbrk 申请动态分配空间而不是放在数据段中。

### 内核应完成功能

* 内核动态内存分配器（对于 Rust 而言，对于 C 仍可以考虑静态分配）
* 物理页帧分配器
* 页表机制，特别是用户和内核地址空间的隔离（参考 xv6）
* ELF 解析和加载（在内核初始化的时候完成全部的地址空间创建和加载即可） 
### 新增系统调用

* sys_sbrk：拓展或缩减当前应用程序的堆空间大小
### 建议实现过程：

1. 在Chapter1的基础上实现基本的物理内存管理机制，即连续内存的动态分配。
2. 在Chapter1的基础上实现基本的页表机制。
3. 然后再合并到Chapter3上。
## Chapter5 进程及重要系统调用（优先级1）

### 主要动机

应用以进程的方式进行运行，简化了应用开发的负担，OS也更好管理

引入重要的进程概念，整合Chapt1~4的内容抽象出进程，实现一系列相关机制及 syscall

### 用户程序

用户终端 user_shell以及一些相应的测试

### 内核应完成功能

实现完整的子进程机制，初始化第一个用户进程 initproc。

### 新增系统调用

* sys_fork
* sys_wait(轮询版)
* sys_exec
* sys_getpid
* sys_yield更新
* sys_exit 更新
* sys_read：终端需要从串口读取命令
## Chapter6 文件系统与进程间通信（优先级1）

### 主要动机

进程之间需要进行一些协作。本章主要是通过管道进行通信。

同时，需要引入文件系统，并通过文件描述符来访问对应类型的 Unix 资源。

### 用户程序

简单的通过 fork 和子进程共享管道的测试；

【可选】强化用户终端的功能，支持使用 | 进行管道连接。

### 内核应完成功能

实现管道。

将字符设备（标准输入/输出）和管道封装为通过文件描述符访问的文件。

### 新增系统调用

* sys_pipe：目前对于管道的 read/write 只需实现轮询版本。
* sys_close：作用是关闭管道
## Chapter7 数据持久化（优先级1）

### 主要动机

实现数据持久化存储。

### 用户程序

多种不同大小的文件读写。

### 内核应完成功能

实现另一种在块设备上持久化存储的文件。

文件系统不需要实现目录。

### 新增系统调用

* sys_open：创建或打开一个文件
# ----------------------------分割线-------------------------------------------------

## Chapter6 单核同步互斥（优先级1，需要划分为单核/多核两部分）

### 主要动机：

应用之间需要在操作系统的帮助下有序共享资源（如串口，内存等）。

解释内核中已有的同步互斥问题，并实现阻塞机制。

### 内核应完成功能：

实现死锁检测机制，并基于阻塞机制实现 sys_sleep 和 sys_wait 以及 sys_kill

### 新增系统调用：

sys_sleep 以及 sys_wait/sys_kill 的更新

### 章节分布：

#### 基于原子指令实现自旋锁

* 讨论并发冲突的来源（单核/多核）
* 关中断/自旋/自旋关中断锁各自什么情况下能起作用，在课上还讲到一种获取锁失败直接 yield 的锁
* 原子指令与内存一致性模型简介
* 具体实现
* 需要说明的是，课上的锁是针对于同一时刻只能有一个进程处于临界区之内。但是 Rust 风格的锁，也就是 Mutex 更加类似于一个管程（尽管 Rust 语言并没有这个概念），它用来保护一个数据结构，保证同一时间只有一个进程对于这个数据结构进行操作，自然保证了一致性。而 xv6 里面的锁只能保护临界区，相对而言对于数据结构一致性的保护就需要更加复杂的讨论。
#### 死锁检测

#### 阻塞的同步原语：条件变量

简单讨论一下其他的同步原语。

* 课上提到的信号量和互斥量（后者是前者的特例）保护的都是某一个临界区
#### 基于条件变量实现 sys_sleep

#### 基于条件变量重新实现 sys_wait

#### 更新 sys_kill 使得支持 kill 掉正在阻塞的进程

## ChapterX IPC（优先级1）

### 主要动机：

应用之间需要交换信息

### 内核应完成功能：

* pipe
* shared mem
### 新增系统调用：

## Chapter8 设备驱动（优先级2）

### 主要动机：

应用可以把I/O 设备用起来。

### 内核应完成功能：

实现块设备驱动和串口驱动，理解同步/异步两种驱动实现方式

#### 背景知识：设备驱动、设备寄存器、轮询、中断

#### 设备树（可选）

#### 实现 virtio_disk 块设备的块读写（同步+轮询风格）

#### 实现 virtio_disk 块设备的块读写（异步+中断风格）

#### 实现串口设备的异步输入和同步输出

* 参考 xv6，可以在内核里面维护一个 FIFO，这样即使串口本身没有 FIFO 也可以
## Chapter9 Unix 资源：文件（优先级1）

### 主要动机：

应用可以通过单一接口（文件）访问磁盘来保存信息和访问其他外设

Unix 万物皆文件，将文件作为进程可以访问的内核资源单位

### 内核应完成功能：

支持三种不同的 Unix 资源：字符设备（串口）、块设备（文件系统）、管道

### 新增系统调用：

sys_open/sys_close

### 背景知识：Unix 万物皆文件/进程对于文件的访问方式

#### file 抽象接口

* 支持 read/write 两种操作，表示 file 到地址空间中一块缓冲区的读写操作
#### 字符设备路线

* 直接将串口设备驱动封装一下即可。
#### 文件系统路线

* 分成多个子章节，等实现出来之后才知道怎么写
#### 管道路线

* 一个非常经典的读者/写者问题。
### ChapterX 虚存管理（优先级2）

### 主要动机：

提高应用执行的效率（侧重内存）

- 支持物理内存不够的情况

- copy on write

### 内核应完成功能：

### 新增系统调用：



### Chapter10 多核（可选）

### 主要动机：

提高应用执行的并行执行效率（侧重多处理器）

### 内核应完成功能：

### 新增系统调用：

#### 多核启动与 IPI

#### 多核调度

### Chapter11多核下的同步互斥（可选）

### 主要动机：

提高应用并行执行下的正确性（侧重多处理器）

### 内核应完成功能：

### 新增系统调用：

#### 多核启动与 IPI

#### 多核调度

## Appendix A Rust 语言快速入门与练习题

## Appendix B 常见构建工具的使用方法

比如 Makefile\ld 等。

## Appendix C RustSBI 与 Kendryte K210 兼容性设计

## 2020.11.01讨论初稿



## Appendix D 操作系统实验：应用驱动、step-by-stage

> 确定不做 x86

类似编译实验，OS 实验也有一个问题就是学生完成实验后仍然缺乏对 OS 的整体观，

 例如 ucore，完成 ucore 实验的学生多数并没有真正理解 ucore，而就是看到局部的注释然后填空。

 据学生反应，rcore 似乎也有类似的问题。

类似新编译实验，新 OS 实验的目的也是：“强化学生对 OS 的整体观念”，为此有几个要素

* 自己从头写，不是填空：强化整体观
* 有参考实现：降低难度
* step-by-step：循序渐进
* **应用**导向的，每个 step 的任务一定不是凭空而来、而是某个**应用**的需求

==============================================================================

###  jyk 和 dzy 的设计

OS 实验分为几个大的 stage，每个 stage 又由若干小的 step 构成。

测例分几种

* 用户程序：运行在用户态，通过 syscall 和 OS 交互，是最终学生必须通过的目标；
* 作为内核拓展：运行在内核态，可以直接调用内核的 API（例如 kmalloc），可以方便学生调试；
  * 实现方法：可替换的 libc（in-kernel 的 libc 用 funccall，in-user 的用 syscall）
* （内嵌在 OS 里面的断言，这个就学生自己写了，我们不讨论）

初步设计：5 个 stage

sys_ 开头的是 syscall，其他的是内核内部 API

###  stage1: 中断

没有地址映射、没有特权级分离，所有测例都是作为内核拓展实现的

系统调用还只是函数，没有 trap dispatch syscall

最简单的输出

1.  1. 测例 hello_world（作为内核拓展）
    2. sys_write（串口轮询、只有 stdout）

输入

1.  1. 测例 a_plus_b、sort（内核拓展）
    2. sys_read（轮询，只有 stdin）

中断异常，时间+串口中断：

1.  1. 测例 div_err、ctrl_c、time_sort
    2. sys_gettime

测例：

* echoserver_exploit（那个经典的栈溢出漏洞）

### stage2: 内存管理

注意，虚拟内存（换入换出）不在这里。

这一步最后会把上一步的函数调用变成真正的 syscall。

1. 物理内存分配：页框分配

内存映射、页表

1.  1. kmalloc、kfree

地址空间隔离 + 特权级隔离

1.  1. sys_mmap、sys_munmap

测例：

* echoserver_exploit_fixed
* sort_malloc
* shellcode_mmap（映射一块 RWX 的内存然后把在 RW 区域的代码 memcpy 过去执行）

### stage3: 任务（线程/进程）管理

内核线程的创建、销毁：没有抢占调度，就是 FIFO

1.  1. clone/spawn/exit

内核线程的抢占式调度

1.  1. 上下文切换
    2. sys_yield, sys_wait

用户线程的创建、销毁：要 forkret，以及加载用户程序

1.  1. exec，ELF 解析
    2. sys_clone/sys_exit/sys_exec

测例：

* 多进程/线程计算（因为单核所以没有效率优势）
* time，给子程序计算时间，代替 time_sort
* 只有内置命令没有文件系统的蹩脚 shell
* reediis-daemon
* 两个程序，一个 IO 密集型（串口交互式），一个计算密集型。如果调度算法选的好，可以大幅优化 IO 密集型的交互响应时间。

### stage4: 并发与多核

单核也有简单的并发，啥时候讲？

有多条执行流可能同时位于内核空间：

[1]内核线程

[2]用户线程的异常处理内核线程

[3]内核线程/用户线程/用户线程的异常处理内核线程**触发中断**再次进入中断处理内核线程

由此带来可能的并发冲突。事实上，单核+全程在内核态+打开中断就已经会触发问题了。

1. 基本概念：spinlock/mutex/semaphore, cas/tas/xchg …

多核启动

1.  1. AP/BSP
2.  用户程序能被调度到不同核上运行，但内核还是 non-reentrant 用一个大锁保护
3.  细粒度的内核锁

>拓展：无锁编程、MCS lock、scalability 

测例：

* 上面的多进程/线程，看效率优化
* 哲学家就餐

### stage5: 存储和外设

1. 驱动和磁盘 I/O
2. 缓冲区 bcache

文件系统

1.  1. 可能实现一个比 SFS 更简单的，没有目录的那种 FS？
    2. 实现一个标准的有目录有 inode 概念的 FS 工作量不小

其他 Unix 资源

1. 将文件系统、字符设备（串口）、IPC（如管道）封装成 Unix 资源类型，可以一致的通过 fd 进行访问，由此实现标准 open/close/read/write 系统调用。（这个好像有点**一定**要有什么那个感觉了）

>拓展：logging FS，网络 I/O 

==============================================================================

###  问题

并不是线性的，例如  线程进程  并不需要内存映射和

抛弃惯性思维：os 不是必须必须要有什么什么。

从应用出发，看 OS 到底需要什么。

## Appendix E Tutorial 代码框架完善计划

1. 不在代码中体现线程的概念，只保留进程 Process 同时作为资源控制和 CPU 调度单位

资源控制：地址空间（复用 MemorySet），打开的文件描述符表

CPU 调度单位：需要保存进程的运行状态、进程的 PID、进程在内核被切换出去之后的上下文（可以被看成一个函数调用，中断上下文在栈上无需保存）、内核栈在进程地址空间中的位置

2. 进程地址空间分布：不对内核和用户地址空间进行隔离

低于 0x80000000：设备 MMIO 的恒等映射

从 0x80000000 开始：用户程序的代码、数据（从 ELF 中解析），接下来属于用户堆区域，可以通过 sbrk 系列系统调用来增长或缩减用户堆的大小

从 0xFFFFFFFF80000000 向下：首先是一个带有 guard page 的进程专属的内核栈，然后是一个带有 guard page 的进程专属的用户栈（需要以某种方式传递*int argc, char* argv[]*参数）

从 0xFFFFFFFF80000000 向上：整块物理内存偏移量为 0xFFFFFFFF00000000 的线性映射，包括 RustSBI 代码、数据段，内核代码、数据（内含启动栈和内核堆），还有剩余可用的物理内存

3. 取消内核线程，将其变为内核进程，在 Process 加一个域表示是否为内核进程，这样易于实现。实现的时候要注意内核进程就无须开一个用户栈了，在 trap 的时候也无需换栈。

4. 子进程与进程回收

除了 Runnable/Running/Sleeping 之外，进程还有一个 Exit 状态，表示它调用 exit 系统调用退出或者是由于某种原因被内核杀死。但是一个进程不能在最后一次进入内核态的时候自己把自己的资源全部回收，主要是因为目前代码还是在它自己的内核栈上面跑的。因此先将其用户代码、数据段包括用户栈回收，然后将其标志为 Exit 状态，并在 PCB 里面保存退出状态。其父进程可以通过 wait 系统调用来获取一个 Exit 的子进程的退出状态，顺带回收它的内核栈和 PCB。

当一个进程退出时，将它的所有子进程让渡给初始进程 initproc，这个进程的任务就是回收之前还没有回收的进程。同时还需要考虑它的父进程，如果它的父进程正处于 wait 子进程退出的状态，则唤醒父进程。因此应该有一个全局的 condvar 来保存所有处于此状态的进程。

xv6 风格由于没有内核堆分配器，因此大多数数据结构的风格都是开一个定长数组，对于内存有一定程度上的浪费。目前 tutorial 无需做到像是 biscuit 那样对于堆内存有着相对容错且稳定的设计，如果**堆内存不足，内核直接 panic**即可。

5. Unix 万物皆文件

即 xv6 里面的 file，这里继承的是 Unix 的万物皆文件哲学，也即每种资源都可以用一个文件描述符来访问，支持 open/close/read/write 等操作。

目前我们预计提供三种不同的资源：首先是文件系统，代表块设备；其次是串口输入输出，代表字符设备；最后是作为 IPC 的管道，作为某种内核资源。

6. 高优先级系统调用

* *int fork()*：fork 出一个子进程，对于父进程返回子进程的 PID，对于子进程返回 0。如果物理页帧不足，则不 fork 子进程并返回 -1。
* *int exit(int status)*：调用 exit 退出进程，该函数不应该返回。传入的 `status` 将作为进程的返回状态，可以被父进程捕获到。
* *int wait(int* status)*：等待**一个**子进程退出并将其返回状态存储在 `status` 里面，其返回值为子进程的 PID。如果该进程没有任何子进程则立即返回 -1，此时应忽略 `status` 里面的值。
* *int getpid()*：返回当前进程的 PID。
* *int exec(char* file, char* argv[])*：用 `file` 处的用户程序替换掉进程地址空间中的用户代码、数据段，清空用户栈并在上面传入 `argv` 作为可以被捕获到的初始参数。可能会消耗更多物理页面，因此如果物理页面不足，应放弃替换并返回 -1；否则不应该返回而是从用户程序的入口点开始执行。
* *int open(char* file, int flags)*：以 `flags` 标志打开位于 `file` 处的 Unix 资源。暂时只支持打开位于块设备文件系统上的文件或目录，而不支持打开 `/dev/tty` 等其他设备。如果成功，返回其 fd；否则返回 -1。
* *int close(int fd)*：释放当前进程的 Unix 资源 `fd`。如果成功返回 0，如果失败（如当前进程不存在资源 `fd`）则应该返回 -1。
* *int write(int fd, char* buf, int n)*：尝试向 Unix 资源 `fd` 内写入 `buf` 开头的 `n` 字节 ，返回实际写入的字节数；*int read(int fd, char* buf, int n)*：尝试从 Unix 资源 `fd` 读 `n` 字节到 `buf` 开头的一块内存，返回实际读到的字节数。注意 `write/read` 的表现随着 `fd` 对应的资源类型（文件系统中的文件/目录 `T_INODE`、串口设备 `T_DEVICE`、管道 `T_PIPE`）不同会发生变化，这里暂且不考虑。
* *int pipe(int p[])*：创建一个管道，返回的两个 fd `p[0], p[1]` 分别表示管道的读端和写端。返回 0。



7. 低优先级系统调用

* *int kill(int pid)*：杀死一个 PID 为 `pid` 的进程。如果成功则返回 0，否则返回 -1。（注意应该不允许杀死自己）
* *int sleep(int n)*：休眠一个进程，时长为 `n` 个 ticks（在调度模型中进程执行 1 个 tick 时候就会切换到其他进程），返回值为 0。
* *char* sbrk(int n)*：增长用户堆内存 `n` 字节，`n` 有可能为负数。 返回这块内存的起始地址，如果物理页面不足则返回 -1 也就是 0xFFFFFFFFFFFFFFFF。（在 libc 内可以将 `sbrk` 包装成 `malloc` 和 `free`，但是在 Rust 里面还是倾向于事先在数据段分配一块用户堆内存用于动态分配 ）
* 创建/删除文件/目录，获取元数据之类的系统调用。

8. 参考 xv6 或者 ucore 实现一个简单的文件系统

最先只需考虑依次实现：磁盘驱动（qemu 平台的 virtio 以及 k210 平台的 sd 卡）的封装、磁盘布局的实现（超级块、inode 和数据块区域及其 bitmap）、将 inode 包装为 Unix 资源类型 file 并实现相应 syscall

时间充裕的话可以考虑实现块缓存或者日志系统

9. 手动实现*spin::Mutex*并解释其原理

只需利用 Rust core::sync::atomic 提供的原子类型 `AtomicBool` 或者参照 xv6 直接用 RISC-V 提供的原子 CAS 系列指令即可。需要说明的是原子指令不仅仅是一条指令进行多个操作，站在多核角度还需要考虑内存一致性模型，以及 Memory Ordering。比如 RISC-V 提供的 LR-SC 指令和普通的 Load/Store 指令一样只有读或者写一个操作，只是设置了 Memory Ordering 之后也能用来实现 spinlock。这部分可以稍微介绍一下，但目前我也不是很懂。

内核中基本上所有的共享资源都需要受到 spinlock 的保护。

之后除了已有的 `CondVar` 之外，还可以在代码或者练习中实现其他同步原语，并在内核中进行测试。

10. 搬运 xv6 中所有能用的测试程序和测试脚本，也可以考虑从 ucore 里面移植一些。

>chyyuu: xv6 中所有能用的测试程序能在linux上运行吗？



## Appendix F 20200906以前的工作纪要 

### 20200906-**rCore实验教材写作讨论**

#### 吴一凡

1. 在qemu和K210上跑rCore了：能运行第一个应用程序，然后就死掉了；
2. 把板级的信息放在board目录下：k210和qemu；
3. bootloader使用rustsbi；
4. rCore可使用RISC-V的规范的1.9.1和部分兼容后续版本；有一处PUM(sstauts)需要处理；缺页异常的处理也有小变化；

#### 下周工作

1. 执行第一个应用后死掉的问题；
2. 跑uCore的所有测试应用

### 20200830-**rCore实验教材写作讨论**

#### 吴一凡

1. 正在写鹏城要求的RISC-V书的一章，快写完了；
2. K210的事：本周没有进展；
3. 徐文浩：开学后就主要精力在课程上了；他的进展是swap和SD卡；

#### 下周工作

1. 先把鹏城的书稿写完，今天能搞完；
2. 把徐文浩的结果接收下来：用rustSBI；
3. 开始做多核；

#### 赵成钢

1. 开学后有5门课，13个学分；
2. 选专题训练是由于兴趣，负担大是可以的；但整体上对高于学分的要求比较敏感；
3. 透明问题：学校没有明确要求；公平性是大家关心的重点；竞争是主要瓶颈，内卷对竞争没有影响；

### 20200823-**rCore实验教材写作讨论**

#### 吴一凡

1. SD卡是通过SPI相连的；最高速度4Mbps；
2. SBI下的OpenSBI和RustSBI都已有IPI支持；
3. 写作风格：原理、数据结构介绍、方法描述、代码注释（函数说明）

#### **下面的工作**

1. 单核还有小错误，完成此修改，并在wiki上提交相关记录；
2. 扩展rCore的多核支持；

#### 蒋周奇

1. DMA放在M态是比较好的；
2. 对RV的新规范的支持：不存在的指令是可以支持的；对改指令是无法支持的（需要CPU有监控模块的支持）；
3. virtio与SBI的关系：在SBI中实现通用I/O接口；
4. 设备树信息在SBI中目前没有规范的接口，是事实标准；
5. RustSBI上面需要有一个测试集，目前还没有；
6. RustSBI内的异步支持，然后改接口；
7. SBI对网卡等需要虚拟化的设备的支持目前还没有，也是可以考虑的方向；

#### 下周工作

1. 完善RustSBI的文档；
   ## 

### 20200816-**rCore实验教材写作讨论**

#### 吴一凡

1. 鹏城的FPGA软核的RV板子：内存有1GB、上面的Linux已经跑通、想写书的一章；
2. K210板子上事儿没有进展；
3. 鹏城的RV板子只是重现，没有加新的东西；

#### 下周工作

1. 需要陈渝与杨沙洲有沟通，吴一凡也要多与鹏城的人多交流；
2. 需要对鹏城的板子有更多的了解；

#### 刘丰源

1. 在网易实习和期末考试，没有进展；

#### 下周工作

1. 先考试吧。

#### 涂轶翔

1. 没有进展；

#### 下周工作

1. 先考试吧。

#### 徐文浩

1. 可能在这里提供Flash的支持；
2. 内存不够用的问题：肖还没有关于内存扩展的进展；
3. 尝试过K210上的Flash和SD卡可以用了；

#### 下周工作

1. 在RustSBI中尝试Flash的支持；
   ## 

### 20200809-**rCore实验教材写作讨论**

吴一凡

1. 时钟和串口可以工作了，SDRAM（8MB）都可以用了；
2. 后续的工作：Flash（16MB）访问没有问题；

#### 下周工作

1. 需要把Flash的访问代码加到rCore的第三版；
2. OpenSBI可以支持在上层用最新的规范；
3. 把蒋周奇和徐文浩加到这个群中；
4. 本周把单核的rCore搞定；
5. 把前面的日志放到仓库中；
   ## 

### 20200802-**rCore实验教材写作讨论**

吴一凡

1. 串口中断的设置：中断产生时寄存器的内容有变化，但变化不对；缓存中的内容有置后；别人的实现都是轮询进行的，有可能是突破口的实现有问题；目前放弃串口尝试；
2. 时钟中断的设置：设置和响应是正常的；在M态的时钟正常；S态的时钟中断响应还有一点儿需要处理的事；道理是，直接在S态处理中断是可以的；
3. 有一个可以工作UART的
4. 串口中断相关进展：[https://github.com/rcore-os/rCore-Tutorial/issues/80#issuecomment-666975262](https://github.com/rcore-os/rCore-Tutorial/issues/80#issuecomment-666975262)

#### 下周工作

1. 优先准备周二的K210介绍；
2. 优先在K210上实现一个核的rCore可以正常工作；
3. 用调试器跟踪一下UART的工作情况；

#### 赵成钢

1. 合并了几个PR；
2. 用CI实现主仓库的Master自动部署另一个部署的仓库；

#### 下周工作

1. 在力所能及的情况下回答同学的问题和处理PR；

### 20200726-**rCore实验教材写作讨论**

#### **刘丰源**

1. rCore的移植已完成，但没有文档；

#### 下周工作

2. 陈老师和向勇看rCore的演示：qemu下的MIPS32环境、还有测试无法完成；搞好后，再演示一遍；
3. 交流zCore的移植思路：目前的代码拆分不理想；先拆到在zCore的编译框架下，只有串口输出；

#### 吴一凡

1. 还在处理K210的启动问题：板子和连线的一致性；
2. 调试器链接还有问题：OpenOCD模块；
3. Linux 0.11在K210上的复现可工作；
4. 在板子上的时钟中断调好了：S态的中断还需要M态的IPI代理中断转交；（是在板子上完成的；M态的中断响应一切正常；S态的异常可以正常处理，但时钟中断和串口可能需要中转；其他同学有帮助吗？有人在做，要尽可能与能合作的人合作；）
5. 串口可以有输出了：把原来的高速串口改成了普通串口，以避免出错；

#### 下周工作

1. 先搞定调试器的连接和正常工作；
2. 用一点儿时间尝试串口的输入；
3. 优先完成rCore的实验在板子上能工作；

#### 涂轶翔

1. 堆栈的命名：运行栈（用户栈）、中断栈（与CPU的绑定）、内核栈（内核线程）；

#### 下周工作

1. 在issue中讨论中断栈的问题；

#### 赵成钢

1. 处理PR；

#### 下周工作


### 20200719-**rCore实验教材写作讨论**

#### 涂轶翔

1. 练习题搞定：原理理解、代码分析、算法设计、实现算法和功能；

#### 下周工作

1. 需要补充线程控制接口实现（退出、等待）；
2. 补充一个简单的系统调用；
3. 完善练习题的语言表达；

#### **吴一凡**

1. 硬件调试器到货；需要注意调试器的质量问题；
2. 中断能收到，但状态不对；在M态可以收到中断，还有不对的状态；手册需要确定是否针对指定的板子；
3. 生成的指令不是应该出现的；

#### 下周工作

1. 先重现王润基的工作，确定中断是可以工作的；
2. 再在一个核上搞定M态的rCore中断；
3. 回复blog的帮助文档链接；

### 20200712-**rCore实验教材写作讨论**

#### **吴一凡**

1. 第二版的rCore可以工作了，但不太稳定，原因是SBI的版本比较早，新版本工作不好；
2. 一个可能的工作，让实习的同学做K210上的SBI；
3. qemu上的多核支持，本周没有进展；
4. 内联汇编从asm变到llvm-asm后，建议在第三版上进行改动；

#### 赵成钢、涂轶翔

1. 把每个实验的依赖代码摘出来，形成最简的代码目录；已完成两个实验；一周后可以完成6个实验；

#### 刘丰源

1. mips上的rCore移植中：正在实验TLB；

#### 讨论

1. 实验章节的安排：前6个实验做单核；后面加多核下的实验（多核、同步、驱动）；
2. 实验进行两个轮回的循环的好处是，用很短的时间进行第一轮的整体概念，然后进行深入的实验；
3. 向勇建议在不同的环境下做6个实验；
4. 如果多核支持涉及的修改少，多核做成单独的一章是更合适的；有一些复习的作用；先实现出来，再说。

### 20200705-**rCore实验教材写作讨论**

#### 赵成钢

由于实习和课程原因，精力有限，约定只参与交流讨论；

建议：对第三版做小的改进；

#### 刘丰源

在龙芯上做rCore的移植：Qemu、龙芯板子；

#### 吴一凡

在qemu上跑rCore

在板子上跑rCore：目前还不能启动内核；

刘晓义可能提供一些帮助；

目前rCore实验文档：只搞多核，异步放在下一个版本再搞；

#### 统一约定

以后所有交流的内容都要在仓库中，并且在纪要中加链接；

仓库版权：GPL V3（这是最后意见）

### 20200628-**rCore实验教材写作讨论**

**实验教材讨论**

**涂轶翔：**

没有进展；

**吴一凡：**

1.OpenSBI已可以工作了；下一步是搞内核加载和多核启动；

2.多核的已有代码分析：

**刘丰源：**

没有进展；目前的精力主要是在zCore上；

**赵成钢：**

没有进展；

板子到货的事：5套，目前还没有发货（今天发）；130元一套；

石墨：向勇设置访问权限；

**大纲讨论：**

调度和切换目前的划分是合理的；

1.完善实验代码：支持多核、可在qemu上运行、解决已发现的bug；

2.完善实验代码：支持多核、可在K210板子上运行、解决已发现的bug；

3.通过讨论，形成全书大纲；

4.吸收前三个版本的优点，选一章来形成第四版的第一个样章模板；

5.依据模板分工进行各章的成稿，形成完整全书；

### **20200621-rCore实验教材写作讨论**

**内核线程**

涂：写得有缺陷，切换时可能有问题。（能否写个测例，给出解决过程）

**板子**

刘丰源、涂轶翔和赵成钢需要板子。（刘丰源负责收集联络）

**多核**

rCore tutorial有一个多核版本，在qemu上可以初步工作（有bug）：[https://github.com/rcore-os/rCore_tutorial/tree/multicore](https://github.com/rcore-os/rCore_tutorial/tree/multicore)

**成绩**

重点是写一本书，不考虑给成绩的事。

**目录**

吴一凡给了一个大纲文档。

顺序需要继续讨论，写完代码后再确定。

### **20200618-rCore实验教材写作讨论**

**知识共享协议**

暂定 GPL 和 CC-SA/CC-BY-NC-SA（分别代表*相同方式共享*以及*署名-非商业性使用-相同方式共享 ,*具体含义可分别参考[https://www.oschina.net/question/54100_9455](https://www.oschina.net/question/54100_9455)和[https://boke112.com/bkwd/5115.html](https://boke112.com/bkwd/5115.html)）

**目标读者**

211 院校（或有等价学习意愿与学习能力）以上要写内核代码的操作系统课学生

**书籍定位/内容侧重**

作为一本实验指导书，应帮助学生较为轻松的跨越较为零碎的操作系统原理与复杂的工程实现之间的鸿沟，并建立自信，培养学习兴趣。需要做到：

1. 需要包含完整的从零开始实现 OS 的过程，强调 OS 核心原理在代码中的对应以及项目各模块功能之间的上下承接，需要让学生真正理解一个程序是如何在软硬件的协同下运行起来的
2. 适当引入操作系统课程中的内容，说明设计上的考量（即为何这样做），同时给学生留有拓展的余地（即怎样做也许更好）
3. 在前两点基础上，整册书需要做到尽可能详细，使得感兴趣的同学不致在阅读过程中卡住，但照顾到兴趣一般的同学，一些与核心内容无关的代码细节或者工具使用相关内容可考虑利用不同字体区分，或下放到代码注释、附录甚至网站评论区中以供查阅，下放的标准随着书籍的成型不断进行考量

**暂时不考虑的内容**

异步编程对于内核开发的影响较大，需要谨慎考量后再加入进来。

**写作风格与规范**

1. 不要使用网络语言，语气尽量严肃，行文要严谨，不留歧义；
2. 代码注释一概采用中文；

**写作流程：**先一起写一个样章确定具体的写作风格，再分章分头撰写，最后互相审核改进。

**重要时间点：**11月份应开始进行内部综合审阅，年底之前将初稿交给出版社

**每周会议时间：**暂定每周日上午 10:00

**近期计划(3~4 周)：**梳理代码，修复 rCore 的 SMP 问题，并移植到 tutorial 中，在 Qemu 和 K210 上跑起来

**新的成员：**做软件所的同学：参与讨论，好的同学参与写作

